# Copyright (c) 2025-2026 SandAI. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
MagiAttention CPP Extensions
"""
from __future__ import annotations
import collections.abc
import torch
import typing

__all__: list[str] = [
    "AttnMaskType",
    "AttnRange",
    "AttnRangeWithRank",
    "AttnRanges",
    "AttnRectangle",
    "AttnRectangles",
    "BICAUSAL",
    "CAUSAL",
    "FULL",
    "GroupCastRanges",
    "INVCAUSAL",
    "KernelBarrier",
    "binary_greedy_parallel_solve",
    "check_valid_cu_seqlens",
    "cut_host_remote_buckets",
    "expand_attn_ranges",
    "is_valid_cu_seqlens",
    "produce",
]

class AttnMaskType:
    """
    Members:

      FULL

      CAUSAL

      INVCAUSAL

      BICAUSAL
    """

    BICAUSAL: typing.ClassVar[AttnMaskType]  # value = <AttnMaskType.BICAUSAL: 3>
    CAUSAL: typing.ClassVar[AttnMaskType]  # value = <AttnMaskType.CAUSAL: 1>
    FULL: typing.ClassVar[AttnMaskType]  # value = <AttnMaskType.FULL: 0>
    INVCAUSAL: typing.ClassVar[AttnMaskType]  # value = <AttnMaskType.INVCAUSAL: 2>
    __members__: typing.ClassVar[
        dict[str, AttnMaskType]
    ]  # value = {'FULL': <AttnMaskType.FULL: 0>, 'CAUSAL': <AttnMaskType.CAUSAL: 1>, 'INVCAUSAL': <AttnMaskType.INVCAUSAL: 2>, 'BICAUSAL': <AttnMaskType.BICAUSAL: 3>}
    @staticmethod
    def from_int_type(arg0: typing.SupportsInt) -> AttnMaskType: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, state: typing.SupportsInt) -> None: ...
    def __str__(self) -> str: ...
    def to_int_type(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AttnRange:
    @staticmethod
    def from_range(attn_range: typing.Any, check: bool = False) -> AttnRange: ...
    def __eq__(self, arg0: typing.Any) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __init__(self, start: typing.SupportsInt, end: typing.SupportsInt) -> None: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: typing.Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def check_valid(
        self,
        start: typing.SupportsInt | None = None,
        end: typing.SupportsInt | None = None,
    ) -> None: ...
    def clone(self) -> AttnRange: ...
    def diff_by(self, other: AttnRange) -> list[AttnRange]: ...
    def intersect(self, other: AttnRange) -> AttnRange: ...
    def intersect_size(self, other: AttnRange) -> int: ...
    def is_empty(self) -> bool: ...
    def is_overlap_with(self, other: AttnRange) -> bool: ...
    def is_subrange_of(self, other: AttnRange) -> bool: ...
    def is_valid(self) -> bool: ...
    def is_valid_close(
        self,
        start: typing.SupportsInt | None = None,
        end: typing.SupportsInt | None = None,
    ) -> bool: ...
    def is_valid_open(
        self,
        start: typing.SupportsInt | None = None,
        end: typing.SupportsInt | None = None,
    ) -> bool: ...
    def offset(self, offset: typing.SupportsInt) -> AttnRange: ...
    def to_naive_range(self) -> tuple: ...
    def to_string(self) -> str: ...
    def truncate(
        self,
        start: typing.SupportsInt | None = None,
        end: typing.SupportsInt | None = None,
    ) -> AttnRange: ...
    def union(self, other: AttnRange) -> list[AttnRange]: ...
    def union_size(self, other: AttnRange) -> int: ...
    @property
    def end(self) -> int: ...
    @end.setter
    def end(self, arg0: typing.SupportsInt) -> None: ...
    @property
    def seqlen(self) -> int: ...
    @property
    def start(self) -> int: ...
    @start.setter
    def start(self, arg0: typing.SupportsInt) -> None: ...

class AttnRangeWithRank(AttnRange):
    def __getstate__(self) -> tuple: ...
    def __init__(
        self,
        rank_set: collections.abc.Set[typing.SupportsInt],
        start: typing.SupportsInt,
        end: typing.SupportsInt,
    ) -> None: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def clone(self) -> AttnRangeWithRank: ...
    @property
    def rank_set(self) -> set[int]: ...
    @rank_set.setter
    def rank_set(self, arg0: collections.abc.Set[typing.SupportsInt]) -> None: ...
    @property
    def seqlen(self) -> int: ...

class AttnRanges:
    _ranges: typing.Any
    @staticmethod
    def from_cu_seqlens(
        cu_seqlens: collections.abc.Sequence[typing.SupportsInt],
        seqlen: typing.SupportsInt,
    ) -> AttnRanges: ...
    @staticmethod
    def from_ranges(ranges: typing.Any, check: bool = False) -> AttnRanges: ...
    def __eq__(self, arg0: typing.Any) -> bool: ...
    def __getitem__(self, index: typing.Any) -> typing.Any: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __init__(self) -> None: ...
    def __iter__(self) -> collections.abc.Iterator: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __setitem__(self, index: typing.Any, range: typing.Any) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def append(self, range: AttnRange, check: bool = False) -> None:
        """
        Append an AttnRange to the AttnRanges
        """
    def check_valid(self) -> None: ...
    def chunk(
        self, chunk_size: typing.SupportsInt, check: bool = True
    ) -> list[AttnRanges]: ...
    def clear(self) -> None:
        """
        Clear the AttnRanges
        """
    def clear_empty(self) -> AttnRanges: ...
    def clone(self) -> AttnRanges: ...
    def extend(self, other: AttnRanges, check: bool = False) -> None:
        """
        Extend the AttnRanges with another AttnRanges
        """
    def find_hole_ranges(
        self,
        other: AttnRanges,
        is_self_merged: bool = False,
        is_other_merged: bool = False,
    ) -> AttnRanges: ...
    def find_overlap_ranges(
        self,
        other: AttnRanges,
        is_self_merged: bool = False,
        is_other_merged: bool = False,
    ) -> AttnRanges: ...
    def insert(
        self, idx: typing.SupportsInt, range: AttnRange, check: bool = False
    ) -> None: ...
    def intersect_size(self) -> int: ...
    def intersect_size_with(self, other: AttnRanges) -> int: ...
    def is_cu_seqlens(self, seqlen: typing.SupportsInt) -> bool: ...
    def is_empty(self) -> bool: ...
    def is_merged(self) -> bool: ...
    def is_non_overlap(self) -> bool: ...
    def is_sorted(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def make_range_local(
        self,
        other_attn_range: AttnRange,
        is_self_merged: bool = False,
        prefix_offset: typing.Any = None,
    ) -> tuple: ...
    def make_ranges_local(
        self, other_attn_ranges: AttnRanges, is_self_merged: bool = False
    ) -> AttnRanges: ...
    def merge(self) -> AttnRanges: ...
    def pop(self, idx: typing.SupportsInt = -1) -> AttnRange: ...
    def reserve(self, capacity: typing.SupportsInt) -> None:
        """
        Reserve the AttnRanges to a specific capacity
        """
    def sort(self) -> AttnRanges: ...
    def sort_ranges(self) -> AttnRanges: ...
    def to_cu_seqlens(self, seqlen: typing.SupportsInt) -> list[int]: ...
    def to_naive_ranges(self) -> list: ...
    def to_tensor(self, device: typing.Any = "cpu") -> torch.Tensor: ...
    def truncate(
        self,
        start: typing.SupportsInt | None = None,
        end: typing.SupportsInt | None = None,
    ) -> AttnRanges: ...
    def union_size(self) -> int: ...
    def union_size_with(self, other: AttnRanges) -> int: ...
    @property
    def end(self) -> int: ...
    @property
    def max_seqlen(self) -> int: ...
    @property
    def points(self) -> list[int]: ...
    @property
    def size(self) -> int: ...
    @property
    def start(self) -> int: ...
    @property
    def total_seqlen(self) -> int: ...

class AttnRectangle:
    k_range: AttnRange
    q_range: AttnRange
    def __eq__(self, arg0: AttnRectangle) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __init__(
        self,
        q_range: AttnRange,
        k_range: AttnRange,
        d_range: AttnRange | None = None,
        mask_type: AttnMaskType | int = ...,
    ) -> None: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def area(self) -> int: ...
    def check_valid(
        self,
        q: AttnRange | None = None,
        k: AttnRange | None = None,
        d: AttnRange | None = None,
    ) -> None: ...
    def clone(self) -> AttnRectangle: ...
    def cut_k(
        self, cut_pos: typing.SupportsInt
    ) -> tuple[AttnRectangle | None, AttnRectangle | None]: ...
    def cut_q(
        self, cut_pos: typing.SupportsInt
    ) -> tuple[AttnRectangle | None, AttnRectangle | None]: ...
    def get_d_range(self) -> AttnRange: ...
    def get_k_range(self) -> AttnRange: ...
    def get_q_range(self) -> AttnRange: ...
    def get_rect_within_k_segment(
        self, k_start: typing.SupportsInt, k_end: typing.SupportsInt
    ) -> AttnRectangle | None: ...
    def get_rect_within_q_segment(
        self, q_start: typing.SupportsInt, q_end: typing.SupportsInt
    ) -> AttnRectangle | None: ...
    def get_valid_or_none(self) -> AttnRectangle: ...
    def intersection_q_id_on_left_boundary(self) -> int: ...
    def intersection_q_id_on_right_boundary(self) -> int: ...
    def is_bi_causal(self) -> bool: ...
    def is_causal(self) -> bool: ...
    def is_full(self) -> bool: ...
    def is_inv_causal(self) -> bool: ...
    def is_valid(
        self,
        q: AttnRange | None = None,
        k: AttnRange | None = None,
        d: AttnRange | None = None,
    ) -> bool: ...
    def shrink_d_range(self) -> bool: ...
    def shrink_k_range(self) -> bool: ...
    def shrink_q_range(self) -> bool: ...
    def to_qk_range_mask_type(self) -> list[tuple[AttnRange, AttnRange, int]]: ...
    @property
    def d_range(self) -> AttnRange: ...
    @d_range.setter
    def d_range(self, arg1: AttnRange | None) -> None: ...

class AttnRectangles:
    @staticmethod
    def from_ranges(
        q_ranges: typing.Any,
        k_ranges: typing.Any,
        mask_types: list,
        check: bool = False,
    ) -> AttnRectangles: ...
    def __eq__(self, arg0: AttnRectangles) -> bool: ...
    def __getitem__(self, arg0: typing.Any) -> typing.Any: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    def __init__(self) -> None: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __setitem__(self, arg0: typing.Any, arg1: typing.Any) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def append(self, rect: AttnRectangle, check: bool = False) -> None: ...
    def area(self) -> int: ...
    def check_valid(self) -> None: ...
    def clear(self) -> None: ...
    def cut_k(
        self, cut_pos: typing.SupportsInt
    ) -> tuple[AttnRectangles, AttnRectangles]: ...
    def cut_q(
        self, cut_pos: typing.SupportsInt
    ) -> tuple[AttnRectangles, AttnRectangles]: ...
    def extend(self, other: AttnRectangles, check: bool = False) -> None: ...
    def get_kv_ranges_union(self) -> AttnRanges: ...
    def get_qo_ranges_union(self) -> AttnRanges: ...
    def get_rects_within_k_segment(
        self, k_start: typing.SupportsInt, k_end: typing.SupportsInt
    ) -> AttnRectangles: ...
    def get_rects_within_q_segment(
        self, q_start: typing.SupportsInt, q_end: typing.SupportsInt
    ) -> AttnRectangles: ...
    def is_empty(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def total_seqlen_kv(self) -> int: ...
    def total_seqlen_qo(self) -> int: ...
    @property
    def size(self) -> int: ...

class GroupCastRanges(AttnRanges):
    def __getstate__(self) -> tuple: ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(
        self,
        cp_size: typing.SupportsInt,
        ranges_per_rank: collections.abc.Sequence[AttnRanges],
        split: bool = True,
    ) -> None: ...
    def __iter__(self) -> collections.abc.Iterator[AttnRangeWithRank]: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def _split(self) -> None: ...
    @property
    def _ranges(self) -> typing.Any:
        """
        Internal list of AttnRangeWithRank objects
        """
    @_ranges.setter
    def _ranges(self, arg1: typing.Any) -> None: ...

class KernelBarrier:
    def __init__(self, target: typing.SupportsInt) -> None: ...
    def __repr__(self) -> str: ...
    def get_value(self) -> int:
        """
        Get current kernel_barrier count value from GPU (for debugging)
        """
    def reset(self) -> None:
        """
        Reset the kernel_barrier count to 0
        """
    def synchronize(self) -> None:
        """
        Launch a spin kernel to wait until count >= target
        """

def binary_greedy_parallel_solve(
    rects: typing.Any,
    host_ranges_q: list,
    host_ranges_k: list,
    num_heads_q: typing.SupportsInt,
    num_heads_kv: typing.SupportsInt,
    num_heads_group: typing.SupportsInt,
    bucket_per_rank: list,
    rank: typing.SupportsInt = -1,
    debug_print: bool = False,
) -> None:
    """
    Optimized Binary-Greedy-Parallel solver implemented in C++
    """

def check_valid_cu_seqlens(
    cu_seqlens: collections.abc.Sequence[typing.SupportsInt],
    seq_len: typing.SupportsInt,
) -> None: ...
def cut_host_remote_buckets(
    bucket_this_rank: AttnRectangles,
    host_ranges_q_this_rank: AttnRanges,
    host_ranges_k_this_rank: AttnRanges,
) -> tuple:
    """
    Optimized version of calc_host_and_remote_bucket_this_rank
    """

def expand_attn_ranges(
    ranges: AttnRanges, stride: typing.SupportsInt, num_heads_group: typing.SupportsInt
) -> AttnRanges:
    """
    Optimized version of _expand_attn_ranges for DynamicAttnSolver
    """

def is_valid_cu_seqlens(
    cu_seqlens: collections.abc.Sequence[typing.SupportsInt],
    seq_len: typing.SupportsInt,
) -> bool: ...
def produce(kernel_barrier: KernelBarrier | None) -> None:
    """
    Launch a producer kernel to increment the kernel_barrier count by 1
    """

BICAUSAL: AttnMaskType  # value = <AttnMaskType.BICAUSAL: 3>
CAUSAL: AttnMaskType  # value = <AttnMaskType.CAUSAL: 1>
FULL: AttnMaskType  # value = <AttnMaskType.FULL: 0>
INVCAUSAL: AttnMaskType  # value = <AttnMaskType.INVCAUSAL: 2>
